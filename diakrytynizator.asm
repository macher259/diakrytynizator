; ********************************************************
; * _____   ______            _____       __  __  ______ *
; *|  __ \ |  ____|    /\    |  __ \     |  \/  ||  ____|*
; *| |__) || |__      /  \   | |  | |    | \  / || |__   *
; *|  _  / |  __|    / /\ \  | |  | |    | |\/| ||  __|  *
; *| | \ \ | |____  / ____ \ | |__| |    | |  | || |____ *
; *|_|  \_\|______|/_/    \_\|_____/     |_|  |_||______|*
; ********************************************************
; Author: Maciej Herdon
; 0. It is a project for a class, so not everything makes sense.
; 1. Input should be ended with EOF.
; 2. THIS PROGRAM DOES NOT FOLLOW THE ABI.
; 3. To compile the file:
;     $ nasm -f elf64 -w+all -w+error -o diakrytynizator.o diakrytynizator.asm
;     $ ld --fatal-warnings -o diakrytynizator diakrytynizator.o
; 4. What does it do?
;     https://moodle.mimuw.edu.pl/mod/assign/view.php?id=47496 
; 5. I think that is all. Enjoy!



global _start



; ***********************************************************************
; *  _____  ____   _   _   _____  _______         _   _  _______  _____ *
; * / ____|/ __ \ | \ | | / ____||__   __| /\    | \ | ||__   __|/ ____|*
; *| |    | |  | ||  \| || (___     | |   /  \   |  \| |   | |  | (___  *
; *| |    | |  | || . ` | \___ \    | |  / /\ \  | . ` |   | |   \___ \ *
; *| |____| |__| || |\  | ____) |   | | / ____ \ | |\  |   | |   ____) |*
; * \_____|\____/ |_| \_||_____/    |_|/_/    \_\|_| \_|   |_|  |_____/ *
; ***********************************************************************


; There are some magic numbers in the code, but I leave them as they are, because I can't think of a name
; better than MAGIC_NUMBER1, MAGIC_NUMBER2, etc. And I have a constant MAGIC_NUMBER already
SYS_READ    	equ     0
SYS_WRITE   	equ	1
SYS_EXIT    	equ	60
STDIN	    	equ 	0
STDOUT	    	equ 	1
BUFF_SIZE   	equ 	2048
MIN_ARGC    	equ 	2               ; minimum number of arguments expected
ERROR           equ     1
SUCCESS         equ     0
ZERO_D          equ     48              ; code of '0' char
NINE_D          equ     57              ; code of '9' char
MAGIC_NUMBER    equ     0x80            ; no idea why I have to use this, used in calculations, just because...
FIRST_1B_NEG    equ     10000000b       ; used to detect characters encoded on 1 byte
NEXT_CATCH      equ     00111111b       ; use AND and get the bits from 2nd-4th byte
BASE            equ     10              ; we are using base 10
NEXT_SHIFT      equ     6               ; constant to be used in calculations
TWO_B_MASK      equ     11000000b       ; control bits of the first byte encoded on 2 bytes are set
THREE_B_MASK    equ     11100000b       ; -||-  but on 3 bytes
FOUR_B_MASK     equ     11110000b       ; -||- but on 4 bytes
TEST_4B         equ     11111000b       ; -||- but on 5 bytes
CATCH_2B        equ     00011111b       ; used to get valuable bits from the first byte of char encoded on 2 bytes
CATCH_3B        equ     00001111b       ; -||- but on 3 bytes
CATCH_4B        equ     00000111b       ; -||- but on 4 bytes
MIN_2B          equ     0x80            ; minimum value encoded on 2 bytes in utf-8
MIN_3B          equ     0x800           ; same, but on 3 byte
MIN_4B          equ     0x10000         ; same, but on 4 bytes
MAX_4B          equ     0x10FFFF        ; the maximum value of character in unicode possible to encode in utf-8
NONE_LEFT       equ     0
ONE_LEFT        equ     6
TWO_LEFT        equ     12
THREE_LEFT      equ     18
GCC_CONST1      equ     8681818192107816089
GCC_SHIFT       equ     19
GCC_MUL         equ     1113984
ENCODE_NEXT_AND equ     0x3F
ENCODE_NEXT_OR  equ     0x80
NEXT_TEST       equ     11000000b
NEXT_TEST_VAL   equ     10000000b
TWO_AND         equ     0x1F
TWO_OR          equ     0xC0
THREE_AND       equ     0x0F
THREE_OR        equ     0xE0
FOUR_AND        equ     0x07
FOUR_OR         equ     0xF0



; ************************
; * ____    _____  _____ *
; *|  _ \  / ____|/ ____|*
; *| |_) || (___ | (___  *
; *|  _ <  \___ \ \___ \ *
; *| |_) | ____) |____) |*
; *|____/ |_____/|_____/ *
; ************************



section .bss
in_buffer  	resb	BUFF_SIZE
out_buffer      resb    BUFF_SIZE



; ***************************************************
; * __  __            _____  _____    ____    _____ *
; *|  \/  |    /\    / ____||  __ \  / __ \  / ____|*
; *| \  / |   /  \  | |     | |__) || |  | || (___  *
; *| |\/| |  / /\ \ | |     |  _  / | |  | | \___ \ *
; *| |  | | / ____ \| |____ | | \ \ | |__| | ____) |*
; *|_|  |_|/_/    \_\\_____||_|  \_\ \____/ |_____/ *
; ***************************************************



; macro made to calculate [value of provided argument] modulo MOD_VAL constant
; modified registers are rdx, rax
; the result is stored into provided argument
; it is optimized modulo operation by a constant based on a code generated by gcc compiler with -O3 flag
; makes the program run ~50% faster than with normal div instruction
%macro my_mod 1
        mov     rdx, GCC_CONST1
        mov     rax, %1
        mul     rdx
        mov     rax, rdx
        shr     rax, GCC_SHIFT
        imul    rdx, rax, GCC_MUL
        mov     rax, %1
        sub     rax, rdx
        mov     %1, rax
%endmacro

; changes arguments on the stack from their string representation into their numeric values
; modifies rsi, rdx, rbx
; passed argument is a pointer to equivalent argv[]
%macro process_arg  1
        xor     esi, esi
        mov     rdi, %1
        xor     ebx, ebx
%%loop_arg:
        mov     bl, [rdi]
        test    bl, bl
        jz      %%endloop_arg           ; break if '\0'
        cmp     bl, ZERO_D       
        jb      exit_failure            ; character is not a digit
        cmp     bl, NINE_D
        ja      exit_failure            ; character is not a digit
        sub     bl, ZERO_D              ; convert digit to a number
        imul    rsi, BASE
        add     rsi, rbx
        my_mod  rsi
        inc     rdi
        jmp     %%loop_arg            
%%endloop_arg:
        mov     rax, rsi
%endmacro

; encodes 2nd-4th byte in utf-8
; modifies rax and registers modified by add_byte
%macro encode_next 1
        mov     eax, r14d
        shr     eax, %1
        and     eax, ENCODE_NEXT_AND
        or      eax, ENCODE_NEXT_OR
        call    add_byte
%endmacro

; reads 2nd-4th byte encoded in utf-8
; modifies r14 and rax registers and registers used by get_byte
%macro  read_next 0
        sal     r14d, NEXT_SHIFT
        call    get_byte
        mov     cl, al
        and     cl, NEXT_TEST
        cmp     cl, NEXT_TEST_VAL
        jne     exit_failure
        and     al, NEXT_CATCH
        add     r14b, al
%endmacro

; adds first byte to our accumulator
; modifies r14 and rax registers
%macro clean_first 1
        xor     r14d, r14d
        add     r14b, al                ; al contains read byte that is the first byte of character in utf-8
        and     r14b, %1                ; unset all bits unset in the argument
%endmacro

; checks if the representation of a character is the shortest possible by comparing character code point with provided argument
; aborts program with error if not
%macro test_char 1
        cmp     r14d, %1                ; %1 should be a correct code point for utf-8 encoding
        jb      exit_failure
%endmacro



; ***********************************
; * _______  ______ __   __ _______ *
; *|__   __||  ____|\ \ / /|__   __|*
; *   | |   | |__    \ V /    | |   *
; *   | |   |  __|    > <     | |   *
; *   | |   | |____  / . \    | |   *
; *   |_|   |______|/_/ \_\   |_|   *
; ***********************************



section .text
_start:
        mov     r12, [rsp]              ; move number of arguments (argc) into r12 register
        cmp     r12, MIN_ARGC           ; check number of arguments
        jl      abort                   ; no polynomial coefficients were provided -> exit and report a failure
        dec     r12                     ; number of polynomial coefficients is argc - 1
        xor     r8d, r8d                ; during preprocessing r8 will mean number of arguments processed
        mov     r9, r12                 ; during preprocessing r9 will hold number of polynomial coefficients provided

; ******************************************************************
; * _                        _  _                                  *
; *| |                      | || |                                 *
; *| |__    __ _  _ __    __| || |  ___      __ _  _ __  __ _  ___ *
; *| '_ \  / _` || '_ \  / _` || | / _ \    / _` || '__|/ _` |/ __|*
; *| | | || (_| || | | || (_| || ||  __/   | (_| || |  | (_| |\__ \*
; *|_| |_| \__,_||_| |_| \__,_||_| \___|    \__,_||_|   \__, ||___/*
; *                                                      __/ |     *
; *                                                     |___/      *
; ******************************************************************

preprocess:                             ; changes arguments from their string representation into numeric one
        cmp     r8, r9                  
        jae     after_pre               ; all arguments provided were preprocessed, we can end this loop
        mov     r10, [16 + rsp + r8 * 8]     ; store processed argument into registers for efficiency
        process_arg r10
        mov     [16 + rsp + r8 * 8], rax     ; exchange argument of type string with equivalent integer
        inc     r8                      ; increase counter of processed arguments
        jmp     preprocess

after_pre:
        xor     r8, r8                  ; number at r8 will mean how many bytes are in input buffer
        xor     r9, r9                  ; number at r9 will mean how many items are in output buffer
        xor     r10, r10                ; number at r10 will mean how many items were processed in input buffer
        jmp     first_byte

; **************************
; * _____       __   ____  *
; *|_   _|     / /  / __ \ *
; *  | |      / /  | |  | |*
; *  | |     / /   | |  | |*
; * _| |_   / /    | |__| |*
; *|_____| /_/      \____/ *
; **************************
                         
; reads up to BUFF_SIZE bytes of data from stdin and saves it into in_buffer
; in case of error program exits with a failure
; in case that no bytes were read program exits with an error code depending when it happened
; modified registers are rax, rdi, rsi, rdx, r8, r10
; we use syscall, so registers rcx and r11 can also be modified
read_data:
        xor     rax, rax                ; move 0 = SYS_READ syscall number into rax register
        mov     rdi, STDIN              ; read from stdin
        mov     rsi, in_buffer
        mov     rdx, BUFF_SIZE          ; read up to BUFF_SIZE bytes
        syscall                         ; calls read(stdin, in_buffer, BUFF_SIZE - r14)
        cmp     rax, 0                  ; check number of bytes read
        je      exit                    ; nothing more to read, we can exit
        jl      exit_failure            ; an error, we abort
        mov     r8, rax                 ; add newly read bytes into our counter
        xor     r10, r10
        ret

; writes [number at r9 register] bytes of data to stdout from out_buffer
; in case of error or partial write program aborts without flushing
; modified registers are rax, rdi, rsi, rdx, r9
; we use syscall so registers rcx and r11 can also be modified
; r9 should contain number of bytes from the left of the buffer that we want to write out
write_data:
        mov     rax, SYS_WRITE          ; use syscall sys_write
        mov     rdi, STDOUT             ; write into stdout
        mov     rsi, out_buffer         ; get bytes from out_buffer
        mov     rdx, r9                 ; write up to [value at r9] bytes
        syscall                         ; calls write(stdout, out_buffer, r9)
        cmp     rax, 0                  ; check number of bytes written
        jl      abort                   ; an error, exit with an error and without flushing
        cmp     rax, r9                 ; compare number of bytes written to our counter
        jl      abort                   ; partial write! abort without flushing!
        xor     r9, r9                  ; all bytes in the buffer were written, update the counter
        ret

; get the next byte from input buffer, if it's empty, read next portion of data
; return the byte in al register
; modifies rcx, r10
; can modify the same registers as read_data
get_byte:
        cmp     r8, r10                 ; check if there are some bytes left to get from buffer
        jne     .nempty                 ; there are some
        call    read_data               ; there aren't, refill buffer
.nempty:
        mov     al, [in_buffer + r10]   ; load next byte from buffer into al register
        inc     r10                     ; increase our counter of bytes read from buffer
        ret

; adds a byte in al register to output buffer
; if a buffer is full, we call write_data
; modified registers are: rcx, r9
; can modify the same registers as write_data
add_byte:
        mov     [out_buffer + r9], al   
        inc     r9                      ; increase counter of bytes in buffer
        cmp     r9, BUFF_SIZE           ; check if buffer is full
        jne     .notfull                ; it is not, do nothing
        call    write_data              ; it is, flush it then
.notfull:
        ret

; ***************************************************
; *     _                        _  _               *
; *    | |                      | |(_)              *
; *  __| |  ___   ___  ___    __| | _  _ __    __ _ *
; * / _` | / _ \ / __|/ _ \  / _` || || '_ \  / _` |*
; *| (_| ||  __/| (__| (_) || (_| || || | | || (_| |*
; * \__,_| \___| \___|\___/  \__,_||_||_| |_| \__, |*
; *                                            __/ |*
; *                                           |___/ *
; ***************************************************

first_byte:
        xor     r14d, r14d              ; we will store here value of next character 
        mov     r15d, SUCCESS
        call    get_byte                ; get first byte
        mov     r15d, ERROR
        mov     cl, al                  ; use cl register as temporary storage for first byte
        and     cl, FIRST_1B_NEG        ; check if it's character encoded on 1 byte 
        test    cl, cl
        jnz     .two_bytes              ; it is not
        call    add_byte                ; it is, just add it to output buffer
        jmp     first_byte
.two_bytes:
        mov     cl, al
        and     cl, THREE_B_MASK        ; check if it's encoded on 2 bytes
        cmp     cl, TWO_B_MASK
        jne     .three_bytes            ; it is not
        jmp     decode_two_bytes        ; it is, decode it then
.three_bytes:
        mov     cl, al
        and     cl, FOUR_B_MASK         ; check if it should be encoded on 3 bytes
        cmp     cl, THREE_B_MASK
        jne     .four_bytes
        jmp     decode_three_bytes
.four_bytes:
        mov     cl, al
        and     cl, TEST_4B             ; check if it should be encoded on 4 bytes
        cmp     cl, FOUR_B_MASK
        jne     exit_failure            ; it is not a character encoded in utf-8 on 1-4 bytes, throw an error
        jmp     decode_four_bytes

; decode character
; value of character in unicode should be stored at r14d afterwards
decode_two_bytes:
        clean_first CATCH_2B
        read_next
        test_char MIN_2B
        jmp     apply_poly              ; our integer is whole, we can proceed

decode_three_bytes:
        clean_first CATCH_3B
        read_next
        read_next
        test_char MIN_3B
        jmp     apply_poly

decode_four_bytes:
        clean_first CATCH_4B
        read_next
        read_next
        read_next
        test_char MIN_4B
        cmp     r14d, MAX_4B            ; check if it isn't too big for our encoding
        ja      exit_failure

; ****************************************************************
; *               _                                  _         _ *
; *              | |                                (_)       | |*
; * _ __    ___  | | _   _  _ __    ___   _ __ ___   _   __ _ | |*
; *| '_ \  / _ \ | || | | || '_ \  / _ \ | '_ ` _ \ | | / _` || |*
; *| |_) || (_) || || |_| || | | || (_) || | | | | || || (_| || |*
; *| .__/  \___/ |_| \__, ||_| |_| \___/ |_| |_| |_||_| \__,_||_|*
; *| |                __/ |                                      *
; *|_|               |___/                                       *
; ****************************************************************

apply_poly:
        sub     r14d, MAGIC_NUMBER
        mov     r13, r12
        xor     r11, r11
.loop:
        dec     r13
        imul    r11, r14
        add     r11, [16 + rsp + r13 * 8]
        my_mod  r11
        test    r13, r13
        jnz     .loop
.end:
        mov     r14d, r11d
        add     r14d, MAGIC_NUMBER

; ****************************************************
; *                              _  _               * 
; *                             | |(_)              *
; *  ___  _ __    ___  ___    __| | _  _ __    __ _ *
; * / _ \| '_ \  / __|/ _ \  / _` || || '_ \  / _` |*
; *|  __/| | | || (__| (_) || (_| || || | | || (_| |*
; * \___||_| |_| \___|\___/  \__,_||_||_| |_| \__, |*
; *                                            __/ |*
; *                                           |___/ *
; ***************************************************

encode:
; we are encoding an integer at 14d into utf-8
; because we are adding MAGIC_NUMBER in polynomial, we won't have to encode anything on less than 2 bytes
; to understand what is happening, one should read an article on wikipedia about utf-8
; if after reading something is not clear enough, grab a piece of paper, pen and do these calculations by hand until you understand
.two_bytes:                             ; encodes character in utf-8 encoding on 2 bytes
        cmp     r14d, MIN_3B
        jae     .three_bytes
        xor     ax, ax
        mov     ax, r14w                ; r14w holds our character's value
        shr     ax, ONE_LEFT
        and     ax, TWO_AND                ; bit level hacking
        or      ax, TWO_OR                
        call    add_byte
        encode_next NONE_LEFT
        jmp     first_byte
.three_bytes:
        cmp     r14d, MIN_4B
        jae     .four_bytes
        xor     eax, eax
        mov     eax, r14d
        shr     eax, TWO_LEFT
        and     eax, THREE_AND
        or      eax, THREE_OR
        call    add_byte
        encode_next ONE_LEFT
        encode_next NONE_LEFT
        jmp     first_byte
.four_bytes:
        xor     eax, eax
        mov     eax, r14d
        shr     eax, THREE_LEFT
        and     eax, FOUR_AND
        or      eax, FOUR_OR
        call    add_byte
        encode_next TWO_LEFT
        encode_next ONE_LEFT
        encode_next NONE_LEFT
        jmp     first_byte

; **********************
; *             _  _   * 
; *            (_)| |  *
; *  ___ __  __ _ | |_ *
; * / _ \\ \/ /| || __|*
; *|  __/ >  < | || |_ *
; * \___|/_/\_\|_| \__|*
; **********************

; exit is called when SYS_READ returns 0
; the error code depends then on whether we were expecting to read something
exit:                                   ; exit with flushing output buffer with error code depending on value held in r15d
        call    write_data
        mov     eax, SYS_EXIT
        mov     edi, r15d
        syscall                         ; call exit([r15d])

; exit_failure is called when an error recurred
exit_failure:                           ; exit with flushing output buffer with error code 1
        call    write_data
; abort is called upon encountering a critical error that prevents us from writing to the stdout
abort:                                  ; exit without flushing the buffer with error code 1
        mov     eax, SYS_EXIT
        mov     edi, ERROR
        syscall                         ; call exit(1)

